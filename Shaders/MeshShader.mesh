#version 460
#extension GL_EXT_mesh_shader : require
#extension GL_ARB_shading_language_include : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_control_flow_attributes: require

#define UNROLL_LOOP [[unroll]]

const uint MESHLET_VERTEX_ITERATIONS    = ((MAX_VERTICES   + MESH_INVOCATION_COUNT - 1) / MESH_INVOCATION_COUNT);
const uint MESHLET_PRIMITIVE_ITERATIONS = ((MAX_PRIMITIVES + MESH_INVOCATION_COUNT - 1) / MESH_INVOCATION_COUNT);

#include "Include/Structures.glsl"

layout (set = 0, binding = 0) uniform UBO 
{
	SceneData data;
} ubo;

layout(local_size_x = MESH_INVOCATION_COUNT) in;
layout(triangles, max_vertices = MAX_VERTICES, max_primitives = MAX_PRIMITIVES) out;

struct UInt16Pos {
	uint16_t x, y, z;
};

struct Norm {
	int16_t x, y;
};

struct Tex {
	uint16_t x, y;
};

// **IMPORTANT**
// use vec3 will round up to vec4
// see https://registry.khronos.org/OpenGL/specs/gl/glspec46.core.pdf setion 7.6.2.2, page 146
// use struct to bypass this. (page 147)
layout(buffer_reference, std430) readonly buffer VertexPosBuffer{ 
	// vec3 position[];
	UInt16Pos position[];
};

layout(buffer_reference, std430) readonly buffer VertexNormBuffer{ 
	Norm normal[];
};

layout(buffer_reference, std430) readonly buffer VertexTexBuffer{ 
	Tex texcoords[];
};

struct Meshlet {
	uint vertexOffset;
	uint triangleOffset;
	uint vertexCount;
	uint triangleCount;
};

layout(buffer_reference, std430) readonly buffer MeshletBuffer{ 
	Meshlet meshlets[];
};

layout(buffer_reference, std430) readonly buffer MeshletVertexBuffer{ 
	uint meshletVertices[];
};

layout(buffer_reference, std430) readonly buffer MeshletTriangleBuffer{ 
	uint8_t meshletTriangles[];
};

layout(buffer_reference, std430) readonly buffer MeshOffsetBuffer{ 
	uint meshOffsets[];
};

layout(buffer_reference, std430) readonly buffer MeshletOffsetBuffer{ 
	uint meshletOffsets[];
};

layout(buffer_reference, std430) readonly buffer MeshletVertexOffsetBuffer{ 
	uint meshletVertexOffsets[];
};

layout(buffer_reference, std430) readonly buffer MeshletTriangleOffsetBuffer{ 
	uint meshletTriangleOffsets[];
};

layout(buffer_reference, std430) readonly buffer MeshletCountBuffer{ 
	uint meshletCounts[];
};

struct Position {
	float x, y, z;
};

struct BoundingBox {
	Position min;
	Position max;
};

layout(buffer_reference, std430) readonly buffer BoundingBoxBuffer{ 
	BoundingBox boundingBoxes[];
};


layout( push_constant ) uniform PushConstants
{	
	mat4 modelMatrix;

	VertexPosBuffer posBuffer;
	VertexNormBuffer normBuffer;
	VertexTexBuffer texBuffer;

	MeshletBuffer meshletBuffer;
	MeshletVertexBuffer meshletVertexBuffer;
	MeshletTriangleBuffer meshletTriangleBuffer;
	MeshOffsetBuffer meshOffsetBuffer;
	MeshletOffsetBuffer meshletOffsetBuffer;
	MeshletVertexOffsetBuffer meshletVertexOffsetBuffer;
	MeshletTriangleOffsetBuffer meshletTriangleOffsetBuffer;
	MeshletCountBuffer meshletCountBuffer;
	BoundingBoxBuffer boundingBoxBuffer;
	BoundingBoxBuffer meshletBoundingBoxBuffer;
} constants;

layout (location = 0) out vec4 OutColor[];
layout (location = 1) out vec3 OutNormal[];
layout (location = 2) out vec3 OutPos[];
layout (location = 3) out vec2 OutUV[];

struct Task {
	uint baseID;
	uint drawID;
};

taskPayloadSharedEXT Task IN;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

void main()
{
	uint meshletID = IN.baseID + gl_WorkGroupID.x;

	if (meshletID >= constants.meshletCountBuffer.meshletCounts[IN.drawID]) {
		SetMeshOutputsEXT(0, 0);		
		return;
	}

	uint meshVertexOffset = constants.meshOffsetBuffer.meshOffsets[IN.drawID];
	uint meshletOffset = constants.meshletOffsetBuffer.meshletOffsets[IN.drawID];
	uint meshletVertexOffset = constants.meshletVertexOffsetBuffer.meshletVertexOffsets[IN.drawID];
	uint meshletTriangleOffset = constants.meshletTriangleOffsetBuffer.meshletTriangleOffsets[IN.drawID];
	
	Meshlet meshlet = constants.meshletBuffer.meshlets[meshletOffset + meshletID];
	uint vertCount = meshlet.vertexCount;
	uint triCount = meshlet.triangleCount;

	SetMeshOutputsEXT(vertCount, triCount);		

	mat4 mvp = ubo.data.viewproj * constants.modelMatrix;

	UNROLL_LOOP
	for (uint i = 0; i < MESHLET_VERTEX_ITERATIONS; ++i) {
		uint idx = i * MESH_INVOCATION_COUNT + gl_LocalInvocationID.x;

		uint verticesID = constants.meshletVertexBuffer.meshletVertices[meshletVertexOffset + meshlet.vertexOffset + idx];

		UInt16Pos encodedPos = constants.posBuffer.position[meshVertexOffset + verticesID];

		BoundingBox box = constants.meshletBoundingBoxBuffer.boundingBoxes[meshletOffset + meshletID];
		vec3 boxMin = vec3(box.min.x, box.min.y, box.min.z);
		vec3 boxMax = vec3(box.max.x, box.max.y, box.max.z);

		vec3 pos = vec3(UnpackUnorm16(encodedPos.x), UnpackUnorm16(encodedPos.y), UnpackUnorm16(encodedPos.z)) * (boxMax - boxMin) + boxMin;

		vec4 wPos = constants.modelMatrix * vec4(pos, 1.0);

		vec4 hPos = ubo.data.viewproj *  wPos;
		gl_MeshVerticesEXT[idx].gl_Position = hPos;
		OutPos[idx] = wPos.xyz;

		Norm packedNorm = constants.normBuffer.normal[meshVertexOffset + verticesID];
		vec2 octNorm = vec2(UnpackSnorm16(packedNorm.x), UnpackSnorm16(packedNorm.y));
		vec3 normal = OctahedronToUnitVector(octNorm);
		OutNormal[idx] = normalize((constants.modelMatrix * vec4(normal, 0.0)).xyz);

		OutColor[idx] = vec4(rand(vec2(meshletID, IN.drawID)), rand(vec2(gl_WorkGroupID.x, IN.drawID)), rand(vec2(meshletID, IN.baseID)), 1.0);

		Tex tex = constants.texBuffer.texcoords[meshVertexOffset + verticesID];
		OutUV[idx] = vec2(UnpackUnorm16(tex.x), UnpackUnorm16(tex.y));
	}

	UNROLL_LOOP
	for (uint i = 0; i < MESHLET_PRIMITIVE_ITERATIONS; ++i) {
		uint idx = i * MESH_INVOCATION_COUNT + gl_LocalInvocationID.x;

		uint temp = meshletTriangleOffset + meshlet.triangleOffset + idx * 3;

		MeshletTriangleBuffer triBuffer = constants.meshletTriangleBuffer;

		uint triID_0 = triBuffer.meshletTriangles[temp];
		uint triID_1 = triBuffer.meshletTriangles[temp + 1];
		uint triID_2 = triBuffer.meshletTriangles[temp + 2];

		gl_PrimitiveTriangleIndicesEXT[idx] = uvec3(triID_0, triID_1, triID_2);
	}
}