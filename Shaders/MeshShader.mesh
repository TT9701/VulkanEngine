#version 460
#extension GL_EXT_mesh_shader : require
#extension GL_ARB_shading_language_include : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

#define MAX_VERTICES 64
#define MAX_PRIMITIVES 124

#include "Include/Structures.glsl"

layout (set = 0, binding = 0) uniform UBO 
{
	SceneData data;
} ubo;

layout(local_size_x = 1) in;
layout(triangles, max_vertices = MAX_VERTICES, max_primitives = MAX_PRIMITIVES) out;

struct Vertex {
	vec4 position;
	vec4 normal;
	vec2 texcoords;
	vec2 padding;
	vec4 tangent;
	vec4 bitangent;
}; 

layout(buffer_reference, std430) readonly buffer VertexBuffer{ 
	Vertex vertices[];
};

layout(buffer_reference, std430) readonly buffer IndexBuffer{ 
	uint indices[];
};

struct Meshlet {
	uint vertexOffset;
	uint triangleOffset;
	uint vertexCount;
	uint triangleCount;
};

layout(buffer_reference, std430) readonly buffer MeshletBuffer{ 
	Meshlet meshlets[];
};

layout(buffer_reference, std430) readonly buffer MeshletVertexBuffer{ 
	uint meshletVertices[];
};

layout(buffer_reference, std430) readonly buffer MeshletTriangleBuffer{ 
	uint8_t meshletTriangles[];
};

layout( push_constant ) uniform PushConstants
{	
	mat4 modelMatrix;
	VertexBuffer vertexBuffer;
	IndexBuffer indexBuffer;
	MeshletBuffer meshletBuffer;
	MeshletVertexBuffer meshletVertexBuffer;
	MeshletTriangleBuffer meshletTriangleBuffer;
} constants;

layout(location = 0) out VertexOutput
{
	vec4 color;
} vertexOutput[];

const vec4[4] positions = {
	vec4( 0.0, -1.0, 0.0, 1.0),
	vec4(-1.0,  1.0, 0.0, 1.0),
	vec4( 1.0,  1.0, 0.0, 1.0),
	vec4( 0.0,  0.0, -1.0, 1.0)
};

const vec4[3] colors = {
	vec4(0.0, 1.0, 0.0, 1.0),
	vec4(0.0, 0.0, 1.0, 1.0),
	vec4(1.0, 0.0, 0.0, 1.0)
};

struct Task {
	uint baseID;
};

taskPayloadSharedEXT Task IN;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

void main()
{
	vertexOutput[0].color = colors[0];
	vertexOutput[1].color = colors[1];
	vertexOutput[2].color = colors[2];

	uint meshletID = IN.baseID + gl_GlobalInvocationID.x;
	if (meshletID >= 3236)		
		SetMeshOutputsEXT(0, 0);
	Meshlet meshlet = constants.meshletBuffer.meshlets[meshletID];

	SetMeshOutputsEXT(meshlet.vertexCount, meshlet.triangleCount);

	mat4 mvp = ubo.data.viewproj * constants.modelMatrix;

	for (uint i = 0; i < meshlet.vertexCount; ++i) {
		uint verticesID = constants.meshletVertexBuffer.meshletVertices[meshlet.vertexOffset + i];
		gl_MeshVerticesEXT[i].gl_Position = mvp * constants.vertexBuffer.vertices[verticesID].position;
		vertexOutput[i].color = vec4(rand(vec2(meshletID, IN.baseID)), rand(vec2(meshletID, gl_GlobalInvocationID.x)), rand(vec2(IN.baseID, gl_GlobalInvocationID.x)), 1.0);
	}

	for (uint i = 0; i < meshlet.triangleCount; ++i) {
		uint triID_0 = constants.meshletTriangleBuffer.meshletTriangles[meshlet.triangleOffset + i * 3 + 0];
		uint triID_1 = constants.meshletTriangleBuffer.meshletTriangles[meshlet.triangleOffset + i * 3 + 1];
		uint triID_2 = constants.meshletTriangleBuffer.meshletTriangles[meshlet.triangleOffset + i * 3 + 2];
		gl_PrimitiveTriangleIndicesEXT[i] = uvec3(triID_0, triID_1, triID_2);
	}
}